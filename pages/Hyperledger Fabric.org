* Chaincode Basics
** For example, if we have ~myFunction(ctx, name, surname)~ and we receive an array of arguments from a caller ["John", "Adams"], then the arguments would be mapped as ~myFunction(ctx, "John", "Adams")~. This is processed without any developer intervention. Every argument is passed as a string, so further conversion might be required. If an unexpected number of parameters are passed, the chaincode will throw an exception.
** ~putState(key string, value: Uint8Array): Promise <void>~: ~putState~ puts the specified key and value into the transaction's writeset as a data-write proposal. ~putState~ does not affect the ledger until the transaction is validated and successfully committed. Key must not be an empty string and must not start with a null character ~(0x00)~.
** ~getState(key: string): Promise<Uint8Array>~: ~getState~ returns the value of the specified key from the ledger. ~getState~ does not read data from the writeset, which has not been committed to the ledger. In other words, ~getState~ does not consider data modified by ~putState~ that has not been committed.
*** Error strategy: If the key does not exist in the state database, an empty array is returned. It is not an error from the ~getState~ perspective, so this case should be processed in the chaincode if necessary.
** ~delState(key: string): Promise<void>~: ~delState~ records the specified key to be deleted in the writeset of the transaction proposal. After transaction validation and commitment, the key and its associated value will be marked as deleted in the ledger: you wonâ€™t be able to find (key, value) in the world state, but you will still have the opportunity to audit the history of all changes of this pair in the blockchain (including updates before deletion).
*** Error strategy: Similar to ~getState~, ~delState~ does not return an error if the key is not in the world state.
**